
#if 0
gboolean tyon_xcelerator_calibration_start(RoccatDevice *device, GError **error) {
    TyonInfo info = { 0 };
    info.function = TYON_INFO_FUNCTION_XCELERATOR_CALIB_START;
    return tyon_info_write(device, &info, error);
}

gboolean tyon_xcelerator_calibration_data(RoccatDevice *device, guint8 min, guint8 mid, guint8 max, GError **error) {
    TyonInfo info = { 0 };
    info.function = TYON_INFO_FUNCTION_XCELERATOR_CALIB_DATA;
    info.xcelerator_min = min;
    info.xcelerator_mid = mid;
    info.xcelerator_max = max;
    return tyon_info_write(device, &info, error);
}

gboolean tyon_xcelerator_calibration_end(RoccatDevice *device, GError **error) {
    TyonInfo info = { 0 };
    info.function = TYON_INFO_FUNCTION_XCELERATOR_CALIB_END;
    return tyon_info_write(device, &info, error);
}


gboolean tyon_info_write(RoccatDevice *device, TyonInfo *info, GError **error) {
    tyon_info_finalize(info);
    return tyon_device_write(device, (gchar const *)info, sizeof(TyonInfo), error);
}

gboolean tyon_reset(RoccatDevice *device, GError **error) {
    TyonInfo info = { 0 };
    info.function = TYON_INFO_FUNCTION_RESET;
    return tyon_info_write(device, &info, error);
}

guint tyon_firmware_version_read(RoccatDevice *device, GError **error) {
    TyonInfo *info;
    guint result;

    info = tyon_info_read(device, error);
    if (!info)
        return kIOReturnSuccess;
    result = info->firmware_version;
    g_free(info);
    return result;
}

TyonMacro *tyon_macro_read(RoccatDevice *tyon, guint profile_index, guint button_index, GError **error) {
    TyonMacro1 *macro1;
    TyonMacro2 *macro2;
    TyonMacro *macro;

    g_assert(profile_index < TYON_PROFILE_NUM);

    gaminggear_device_lock(GAMINGGEAR_DEVICE(tyon));

    if (!tyon_select(tyon, profile_index, TYON_CONTROL_DATA_INDEX_MACRO_1, button_index, error)) {
        gaminggear_device_unlock(GAMINGGEAR_DEVICE(tyon));
        return NULL;
    }

    macro1 = (TyonMacro1 *)tyon_device_read(tyon, TYON_REPORT_ID_MACRO, sizeof(TyonMacro1), error);
    if (!macro1) {
        gaminggear_device_unlock(GAMINGGEAR_DEVICE(tyon));
        return NULL;
    }

    if (!tyon_select(tyon, profile_index, TYON_CONTROL_DATA_INDEX_MACRO_2, button_index, error)) {
        gaminggear_device_unlock(GAMINGGEAR_DEVICE(tyon));
        g_free(macro1);
        return NULL;
    }

    macro2 = (TyonMacro2 *)tyon_device_read(tyon, TYON_REPORT_ID_MACRO, sizeof(TyonMacro2), error);
    if (!macro2) {
        gaminggear_device_unlock(GAMINGGEAR_DEVICE(tyon));
        g_free(macro1);
        return NULL;
    }

    gaminggear_device_unlock(GAMINGGEAR_DEVICE(tyon));

    macro = (TyonMacro *)g_malloc(sizeof(TyonMacro));
    memcpy(macro, macro1->data, TYON_MACRO_1_DATA_SIZE);
    memcpy((guint8 *)macro + TYON_MACRO_1_DATA_SIZE, macro2->data, TYON_MACRO_2_DATA_SIZE);

    g_free(macro1);
    g_free(macro2);

    return macro;
}



TyonControlUnit *tyon_control_unit_read(RoccatDevice *tyon, GError **error) {
    return (TyonControlUnit *)tyon_device_read(tyon, TYON_REPORT_ID_CONTROL_UNIT, sizeof(TyonControlUnit), error);
}

static gboolean tyon_control_unit_write(RoccatDevice *tyon, TyonControlUnit const *data, GError **error) {
    return tyon_device_write(tyon, (char const *)data, sizeof(TyonControlUnit), error);
}

gboolean tyon_tracking_control_unit_test(RoccatDevice *tyon, guint dcu, guint median, GError **error) {
    TyonControlUnit control_unit;

    control_unit.report_id = TYON_REPORT_ID_CONTROL_UNIT;
    control_unit.size = sizeof(TyonControlUnit);
    control_unit.dcu = dcu;
    control_unit.tcu = TYON_TRACKING_CONTROL_UNIT_ON;
    control_unit.median = median;
    control_unit.action = TYON_CONTROL_UNIT_ACTION_CANCEL;

    return tyon_control_unit_write(tyon, &control_unit, error);
}

gboolean tyon_tracking_control_unit_cancel(RoccatDevice *tyon, guint dcu, GError **error) {
    return tyon_tracking_control_unit_test(tyon, dcu, 0, error);
}

gboolean tyon_tracking_control_unit_accept(RoccatDevice *tyon, guint dcu, guint median, GError **error) {
    TyonControlUnit control_unit;

    control_unit.report_id = TYON_REPORT_ID_CONTROL_UNIT;
    control_unit.size = sizeof(TyonControlUnit);
    control_unit.dcu = dcu;
    control_unit.tcu = TYON_TRACKING_CONTROL_UNIT_ON;
    control_unit.median = median;
    control_unit.action = TYON_CONTROL_UNIT_ACTION_ACCEPT;

    return tyon_control_unit_write(tyon, &control_unit, error);
}

gboolean tyon_tracking_control_unit_off(RoccatDevice *tyon, guint dcu, GError **error) {
    TyonControlUnit control_unit;

    control_unit.report_id = TYON_REPORT_ID_CONTROL_UNIT;
    control_unit.size = sizeof(TyonControlUnit);
    control_unit.dcu = dcu;
    control_unit.tcu = TYON_TRACKING_CONTROL_UNIT_OFF;
    control_unit.median = 0;
    control_unit.action = TYON_CONTROL_UNIT_ACTION_OFF;

    return tyon_control_unit_write(tyon, &control_unit, error);
}

guint tyon_distance_control_unit_get(RoccatDevice *tyon, GError **error) {
    TyonControlUnit *control_unit;
    guint retval;

    control_unit = tyon_control_unit_read(tyon, error);
    if (!control_unit)
        return 0;

    retval = control_unit->dcu;
    g_free(control_unit);
    return retval;
}

gboolean tyon_distance_control_unit_try(RoccatDevice *tyon, guint new_dcu, GError **error) {
    TyonControlUnit control_unit;

    control_unit.report_id = TYON_REPORT_ID_CONTROL_UNIT;
    control_unit.size = sizeof(TyonControlUnit);
    control_unit.dcu = new_dcu;
    control_unit.tcu = 0xff;
    control_unit.median = 0xff;
    control_unit.action = TYON_CONTROL_UNIT_ACTION_UNDEFINED;

    return tyon_control_unit_write(tyon, &control_unit, error);
}

gboolean tyon_distance_control_unit_cancel(RoccatDevice *tyon, guint old_dcu, GError **error) {
    TyonControlUnit control_unit;

    control_unit.report_id = TYON_REPORT_ID_CONTROL_UNIT;
    control_unit.size = sizeof(TyonControlUnit);
    control_unit.dcu = old_dcu;
    control_unit.tcu = 0xff;
    control_unit.median = 0xff;
    control_unit.action = TYON_CONTROL_UNIT_ACTION_CANCEL;

    return tyon_control_unit_write(tyon, &control_unit, error);
}

gboolean tyon_distance_control_unit_accept(RoccatDevice *tyon, guint new_dcu, GError **error) {
    TyonControlUnit control_unit;

    control_unit.report_id = TYON_REPORT_ID_CONTROL_UNIT;
    control_unit.size = sizeof(TyonControlUnit);
    control_unit.dcu = new_dcu;
    control_unit.tcu = 0xff;
    control_unit.median = 0xff;
    control_unit.action = TYON_CONTROL_UNIT_ACTION_ACCEPT;

    return tyon_control_unit_write(tyon, &control_unit, error);
}
#endif

/* Called by Mac OSX multiple times for same single device */
#if 0
static inline void deviceMatched(void *context, IOReturn result, void *, IOHIDDeviceRef device)
{
    if (result != 0) {
        qCritical("[HIDDEV] Device matcher IOResult none zero: %d", result);
        return;
    }

    IOReturn ret = IOHIDDeviceOpen(device, kIOHIDOptionsTypeSeizeDevice);
    if (ret != kIOReturnSuccess) {
        return;
    }

#ifdef QT_DEBUG
    qDebug("[HIDDEV] Device %p found. -----------------------------", device);
#endif

    RTHidDevice *ctx;
    if ((ctx = dynamic_cast<RTHidDevice *>((QObject *) context))) {
        //emit ctx->deviceFoundCallback(result, device);
        ctx->onDeviceFound(device);
    }
}
#endif

#if 0
    IOHIDManagerRef manager = IOHIDManagerCreate(kCFAllocatorDefault, kIOHIDOptionsTypeNone);
    if (!manager) {
        qCritical() << "[HIDDEV] Unable to create IOHIDManager instance.";
        emit deviceError(EINVAL, "Unable to connect HID manager.");
        return;
    }

    // Device-Matching: Only ROCCAT Tyon
    CFMutableDictionaryRef matchingDict = CFDictionaryCreateMutable( //
        kCFAllocatorDefault,
        0,
        &kCFTypeDictionaryKeyCallBacks,
        &kCFTypeDictionaryValueCallBacks);

    CFNumberRef vendorId = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &ROCCAT_VENDOR_ID);
    CFNumberRef productId = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &ROCCAT_TYON_RID);

    CFDictionarySetValue(matchingDict, CFSTR(kIOHIDVendorIDKey), vendorId);
    CFDictionarySetValue(matchingDict, CFSTR(kIOHIDProductIDKey), productId);

    IOHIDManagerSetDeviceMatching(manager, matchingDict);
    CFRelease(matchingDict);
    CFRelease(vendorId);
    CFRelease(productId);

    IOHIDManagerRegisterDeviceMatchingCallback(manager, deviceMatched, this);
    IOHIDManagerScheduleWithRunLoop(manager, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
    IOHIDManagerOpen(manager, kIOHIDOptionsTypeNone);
    //CFRunLoopRun(); // wait for completion
    //return (m_devices.isEmpty() ? ENODEV : kIOReturnSuccess);
#endif


#if 0
    inline int hidWriteRaw(IOHIDDeviceRef device, quint8 const *buffer, ssize_t length);
#endif

#if 0
inline int RTHidDevice::hidWriteRaw(IOHIDDeviceRef device, const quint8 *buffer, ssize_t length)
{
    m_profiles.clear();
    qApp->processEvents();

    auto writeByOSX = [this, device, buffer, length]() -> IOReturn {
        IOReturn ret = kIOReturnSuccess;
        const IOHIDReportType hrt = toMacOSReportType(TYON_INTERFACE_MOUSE);
        const quint8 reportId = buffer[0];
        const CFTimeInterval timeout = 2.0f;
        const uint8_t *payload = (const uint8_t *) &buffer[1];
        m_isCBComplete = false;
        //ret = IOHIDDeviceSetReport(device, hrt, buffer[0], payload, length);
        ret = IOHIDDeviceSetReportWithCallback( //
            device,
            hrt,
            reportId,
            payload,
            length,
            timeout,         // Timeout in Sekunden
            _reportCallback, // Callback-Funktion
            this             // context
        );

        if (ret != kIOReturnSuccess) {
            qCritical("[HIDDEV] Unable to write HID raw message. ret=0x%08x", ret);
            return ret;
        }

        auto checkComplete = [this]() -> bool {
            QMutexLocker lock(&m_mutex);
            return m_isCBComplete;
        };

        QDeadlineTimer dt(500, Qt::PreciseTimer);
        do {
            if (checkComplete()) {
                break;
            }
            qApp->processEvents();
        } while (!dt.hasExpired());

        if (dt.hasExpired()) {
            qCritical("[HIDDEV] Timeout while waiting for HID device %p.", device);
            return EIO;
        }
        return kIOReturnSuccess;
    };

    auto writeByHidApi = [this, buffer, length]() -> IOReturn {
        IOReturn ret = kIOReturnSuccess;
        hid_device *handle;
#ifdef QT_DEBUG
        wchar_t wstr[HIDAPI_MAX_STR];
#endif

        if (!m_hasHidApi) {
            qCritical("[HIDDEV] HIDAPI not initialized.");
            return ENODEV;
        }

        // Open the device using the VID, PID,
        // and optionally the Serial number.
        handle = hid_open( //
            USB_DEVICE_ID_VENDOR_ROCCAT,
            USB_DEVICE_ID_ROCCAT_TYON_BLACK,
            NULL);
        if (!handle) {
            qCritical("[HIDDEV] Unable to open device.");
            return ENODEV;
        }

#ifdef QT_DEBUG
        // Read the Manufacturer String
        ret = hid_get_manufacturer_string(handle, wstr, HIDAPI_MAX_STR);
        if (ret) {
            QString msg = QString::fromStdWString(hid_error(handle));
            qCritical("[HIDDEV] Unable to get device manufacturer. ret=0x%08x (%s)", ret, qPrintable(msg));
            goto func_exit;
        }
        qDebug("[HIDDEV] Manufacturer String: %s", qPrintable(QString::fromStdWString(wstr)));
#endif

#ifdef QT_DEBUG
        // Read the Product String
        ret = hid_get_product_string(handle, wstr, HIDAPI_MAX_STR);
        if (ret) {
            QString msg = QString::fromStdWString(hid_error(handle));
            qCritical("[HIDDEV] Unable to get device product id. ret=0x%08x (%s)", ret, qPrintable(msg));
            goto func_exit;
        }
        qDebug("[HIDDEV] Product String: %s", qPrintable(QString::fromStdWString(wstr)));
#endif

#ifdef QT_DEBUG
        // Read the Serial Number String
        ret = hid_get_serial_number_string(handle, wstr, HIDAPI_MAX_STR);
        if (ret) {
            QString msg = QString::fromStdWString(hid_error(handle));
            qCritical("[HIDDEV] Unable to get device serial number. ret=0x%08x (%s)", ret, qPrintable(msg));
            goto func_exit;
        }
        qDebug("[HIDDEV] Serial Number String: %s", qPrintable(QString::fromStdWString(wstr)));
#endif

        // write HID message
        ret = hid_write(handle, buffer, length);
        //ret = hid_send_output_report(handle, buffer, length);
        //ret = hid_send_feature_report(handle, buffer, length);
        if (ret != length) {
            QString msg = QString::fromStdWString(hid_error(handle));
            qCritical("[HIDDEV] Unable to write HID message. ret=0x%08x (%s)", ret, qPrintable(msg));
            goto func_exit;
        } else {
            ret = kIOReturnSuccess;
        }

    func_exit:
        hid_close(handle);
        return ret;
    };

    if (!device) {
        IOReturn ret;
        if ((ret = writeByHidApi()) != kIOReturnSuccess) {
            return ret;
        }
        return kIOReturnSuccess;
    }

    return writeByOSX();
}
#endif
